"""
signal_bot_with_rsi_atr.py
Educational signal bot + backtester with:
 - SMA crossover entry
 - RSI filter (momentum confirmation)
 - ATR-based volatility stop (Chandelier/ATR stop)
 - Fixed-fraction position sizing (risk percent per trade)
 - TP (take-profit) and SL (stop-loss) mechanics

This is NOT financial advice. No guarantees. Use paper trading, out-of-sample tests.
"""

import pandas as pd
import numpy as np
import yfinance as yf
from datetime import time
import math

# -----------------------------
# PARAMETERS (tune these)
# -----------------------------
SYMBOL = "BTC-USD"        # yfinance symbol
START = "2023-01-01"
END = None
INTERVAL = "1d"           # "1d", "1h", "1m" (yfinance supports limited intraday)
FAST_SMA = 10
SLOW_SMA = 30

# RSI settings
RSI_PERIOD = 14           # typical default
RSI_MIN = 50              # require RSI > RSI_MIN to confirm long momentum (tunable)
RSI_MAX = 90              # optional: avoid extreme RSI if desired

# ATR / volatility stop settings
ATR_PERIOD = 14
ATR_MULTIPLIER = 3.0      # common choices: 2.0 - 3.0

# TP/SL (secondary exits); TP is percent, SL_pct is percent fallback
TP_PCT = 0.05             # 5% take-profit (optional)
SL_PCT_FALLBACK = 0.02    # 2% fixed stop as fallback if volatility stop isn't desired

# Position sizing / risk
RISK_PER_TRADE = 0.01     # risk 1% of equity per trade (fixed-fraction sizing)

# Time-to-open (HH:MM) - set to None to ignore; for intraday testing
TIME_TO_OPEN = None       # e.g. "09:30"  (ignored for daily bars)
# -----------------------------

def fetch_data(symbol, start, end, interval="1d"):
    df = yf.download(symbol, start=start, end=end, interval=interval, progress=False)
    if df.empty:
        raise RuntimeError(f"No data for {symbol}")
    df = df[['Open','High','Low','Close','Adj Close','Volume']].copy()
    df.columns = [c.lower().replace(' ', '_') for c in df.columns]
    return df

def compute_indicators(df):
    # SMAs
    df['sma_fast'] = df['close'].rolling(FAST_SMA, min_periods=1).mean()
    df['sma_slow'] = df['close'].rolling(SLOW_SMA, min_periods=1).mean()

    # SMA crossover entry flags
    df['sma_signal'] = np.where(df['sma_fast'] > df['sma_slow'], 1, 0)
    df['sma_entry'] = df['sma_signal'].diff().fillna(0) > 0

    # RSI (Wilder's RSI)
    delta = df['close'].diff()
    up = delta.clip(lower=0)
    down = -1 * delta.clip(upper=0)
    ma_up = up.ewm(alpha=1/RSI_PERIOD, adjust=False).mean()
    ma_down = down.ewm(alpha=1/RSI_PERIOD, adjust=False).mean()
    rs = ma_up / ma_down
    df['rsi'] = 100 - (100 / (1 + rs))

    # ATR
    df['tr1'] = df['high'] - df['low']
    df['tr2'] = (df['high'] - df['close'].shift(1)).abs()
    df['tr3'] = (df['low'] - df['close'].shift(1)).abs()
    df['tr'] = df[['tr1','tr2','tr3']].max(axis=1)
    df['atr'] = df['tr'].rolling(ATR_PERIOD, min_periods=1).mean()

    # Highest high over ATR period (for chandelier exit)
    df['hh_period'] = df['high'].rolling(ATR_PERIOD, min_periods=1).max()

    return df

def parse_time_to_open(tstr):
    if not tstr:
        return None
    hh, mm = [int(x) for x in tstr.split(":")]
    return time(hh, mm)

def backtest(df,
             tp_pct=TP_PCT,
             sl_pct_fallback=SL_PCT_FALLBACK,
             atr_mult=ATR_MULTIPLIER,
             risk_per_trade=RISK_PER_TRADE,
             time_to_open_str=TIME_TO_OPEN,
             verbose=False):
    tto = parse_time_to_open(time_to_open_str)
    equity = 10000.0
    position = None
    trades = []

    for idx, row in df.iterrows():
        # Evaluate current open position first
        if position is not None:
            # Compute current volatility stop (Chandelier long): highest high over N - ATR * mult
            # Using precomputed hh_period & atr at current index
            vol_stop = row['hh_period'] - (row['atr'] * atr_mult)
            # For simpler single-bar decisions: check if current bar low <= vol_stop -> exit
            hit_vol_stop = row['low'] <= vol_stop if not math.isnan(vol_stop) else False

            # Also check TP/SL based on entry values
            hit_tp = row['high'] >= position['tp']
            hit_sl = row['low'] <= position['sl']

            # Resolve conflicts: if multiple hits same bar, conservative ordering: baseline SL first
            exit_reason = None
            exit_price = None
            if hit_sl:
                exit_reason = 'sl'
                exit_price = max(position['sl'], row['open'])  # conservative: prefer stop price
            elif hit_vol_stop:
                exit_reason = 'vol_stop'
                exit_price = vol_stop
            elif hit_tp:
                exit_reason = 'tp'
                exit_price = position['tp']

            if exit_reason:
                # compute size-based realized pnl
                size = position['size']  # number of units
                realized = (exit_price - position['entry_price']) * size
                equity += realized
                trades.append({
                    'entry_index': position['entry_index'],
                    'exit_index': idx,
                    'entry_price': position['entry_price'],
                    'exit_price': exit_price,
                    'exit_reason': exit_reason,
                    'size': size,
                    'pnl': realized,
                    'equity_after': equity
                })
                if verbose:
                    print(f"[{idx}] Closed {exit_reason} entry {position['entry_price']:.4f} exit {exit_price:.4f} pnl {realized:.2f}")
                position = None
                # no new entry same bar for simplicity
                continue

        # No open position: check entry conditions
        if position is None and row.get('sma_entry', False):
            # RSI filter: require RSI above threshold to confirm momentum (tunable)
            rsi_ok = (not math.isnan(row.get('rsi', float('nan')))) and (row['rsi'] >= RSI_MIN)
            if not rsi_ok:
                if verbose:
                    print(f"[{idx}] Skipping entry due to RSI {row.get('rsi')}")
                continue

            # Time-to-open check (for intraday bars only)
            if tto is not None and isinstance(idx, pd.Timestamp) and (idx.time() < tto):
                if verbose:
                    print(f"[{idx}] Skipping entry due to time-to-open {tto}")
                continue

            # Determine entry price (we'll assume we get the next bar open = current open here)
            entry_price = row['open']

            # Compute ATR-based volatility stop (Chandelier long)
            # Use hh_period and atr at this same index
            vol_stop = row['hh_period'] - (row['atr'] * atr_mult)
            # Fallback stop: percentage-based if vol_stop is NaN or would be >= entry
            if math.isnan(vol_stop) or vol_stop >= entry_price:
                stop_price = entry_price * (1 - sl_pct_fallback)
            else:
                stop_price = vol_stop

            # Compute take-profit price (percentage)
            tp_price = entry_price * (1 + tp_pct)

            # Position sizing: risk fixed fraction of equity
            risk_amount = equity * risk_per_trade
            risk_per_unit = entry_price - stop_price
            if risk_per_unit <= 0:
                if verbose:
                    print(f"[{idx}] Invalid risk per unit (<=0). Skipping entry.")
                continue
            size = risk_amount / risk_per_unit
            # Protect against absurdly large sizes on tiny denominators
            size = max(0, size)

            # Save position
            position = {
                'entry_price': entry_price,
                'entry_index': idx,
                'tp': tp_price,
                'sl': stop_price,
                'size': size
            }
            if verbose:
                print(f"[{idx}] Opened long entry {entry_price:.4f} size {size:.4f} tp {tp_price:.4f} sl {stop_price:.4f}")

    # End of data: close remaining position at last close (mark-to-market)
    if position is not None:
        last_price = df.iloc[-1]['close']
        realized = (last_price - position['entry_price']) * position['size']
        equity += realized
        trades.append({
            'entry_index': position['entry_index'],
            'exit_index': df.index[-1],
            'entry_price': position['entry_price'],
            'exit_price': last_price,
            'exit_reason': 'mkt_close',
            'size': position['size'],
            'pnl': realized,
            'equity_after': equity
        })
        position = None

    trades_df = pd.DataFrame(trades)
    results = {
        'start_equity': 10000.0,
        'end_equity': equity,
        'n_trades': len(trades_df),
        'trades': trades_df
    }
    if len(trades_df) > 0:
        results['win_rate'] = (trades_df['pnl'] > 0).mean()
        results['total_pnl'] = trades_df['pnl'].sum()
    else:
        results['win_rate'] = None
        results['total_pnl'] = 0.0

    return results

def run_demo():
    print("Fetching data for:", SYMBOL)
    df = fetch_data(SYMBOL, START, END, INTERVAL)
    df = compute_indicators(df)
    print("Data:", df.index[0], "->", df.index[-1])
    res = backtest(df, tp_pct=TP_PCT, sl_pct_fallback=SL_PCT_FALLBACK,
                   atr_mult=ATR_MULTIPLIER, risk_per_trade=RISK_PER_TRADE,
                   time_to_open_str=TIME_TO_OPEN, verbose=False)
    print("Start equity:", res['start_equity'])
    print("End equity:  ", res['end_equity'])
    print("Trades:      ", res['n_trades'])
    print("Win rate:    ", res['win_rate'])
    print("Total PnL:   ", res['total_pnl'])
    if res['n_trades'] > 0:
        print(res['trades'].head().to_string(index=False))

if __name__ == "__main__":
    run_demo()
